import requests
import json
import re
import time
import telebot
import random
import logging
from datetime import datetime

# ================= –ù–ê–°–¢–†–û–ô–ö–ò =================
# ‚ö†Ô∏è –í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –ù–û–í–´–ô —Ç–æ–∫–µ–Ω –ø–æ—Å–ª–µ –æ—Ç–∑—ã–≤–∞ —Å—Ç–∞—Ä–æ–≥–æ!
TELEGRAM_TOKEN = '8250615686:AAEb5LeS8MOZ_8Lykk_8lX_twt7IZ9EqM84'
CHAT_ID = '-1003705403133'

# --- –ü–û–õ–ù–´–ï –ù–ê–ó–í–ê–ù–ò–Ø (–¥–ª—è Telegram) ---
LAB_NAMES = {
    "20488344": "1. –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –º–æ–ª–µ–∫—É–ª—è—Ä–Ω–æ–π –∞–¥—Å–æ—Ä–±—Ü–∏–∏ —Ä–∞—Å—Ç–≤–æ—Ä–µ–Ω–Ω–æ–≥–æ –≤–µ—â–µ—Å—Ç–≤–∞ –∏–∑ —Ä–∞—Å—Ç–≤–æ—Ä–æ–≤ –Ω–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —É–≥–ª–µ",
    "21516103": "2. –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –æ–±–º–µ–Ω–Ω–æ–π –∞–¥—Å–æ—Ä–±—Ü–∏–∏ –∏–æ–Ω–æ–≤",
    "20488811": "3. –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ —Ä–∞–∑–¥–µ–ª–∞ —Ñ–∞–∑: —Ä–∞—Å—Ç–≤–æ—Ä –ü–ê–í ‚Äì –≤–æ–∑–¥—É—Ö",
    "21516160": "4. –¢—É—Ä–±–∏–¥–∏–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∫–æ–ª–ª–æ–∏–¥–Ω—ã—Ö —Å–∏—Å—Ç–µ–º ‚Äî –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —á–∞—Å—Ç–∏—Ü",
    "21516155": "5. –ò–∑—É—á–µ–Ω–∏–µ –∫–æ–∞–≥—É–ª—è—Ü–∏–∏ –≥–∏–¥—Ä–æ–∑–æ–ª—è –≥–∏–¥—Ä–æ–∫—Å–∏–¥–∞ –∂–µ–ª–µ–∑–∞",
    "20496685": "5. –ò–∑—É—á–µ–Ω–∏–µ –∫–æ–∞–≥—É–ª—è—Ü–∏–∏ –≥–∏–¥—Ä–æ–∑–æ–ª—è –≥–∏–¥—Ä–æ–∫—Å–∏–¥–∞ –∂–µ–ª–µ–∑–∞ (–¥—É–±–ª—å)",
    "21516163": "6. –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–∏–æ—Ñ–æ–±–Ω—ã—Ö –∑–æ–ª–µ–π",
    "21575413": "7. –ó–∞—Ä—è–¥ –≥—Ä–∞–Ω—É–ª—ã"
}

# --- –ö–û–†–û–¢–ö–ò–ï –ù–ê–ó–í–ê–ù–ò–Ø (–¢–û–õ–¨–ö–û –¥–ª—è –ª–æ–≥–æ–≤) ---
LAB_SHORT_NAMES = {
    "20488344": "–ê–¥—Å–æ—Ä–±—Ü–∏—è (—É–≥–æ–ª—å)",
    "21516103": "–ê–¥—Å–æ—Ä–±—Ü–∏—è (–∏–æ–Ω—ã)",
    "20488811": "–ü–ê–í",
    "21516160": "–¢—É—Ä–±–∏–¥–∏–º–µ—Ç—Ä–∏—è",
    "21516155": "–ö–æ–∞–≥—É–ª—è—Ü–∏—è 1",
    "20496685": "–ö–æ–∞–≥—É–ª—è—Ü–∏—è 2",
    "21516163": "–ó–æ–ª–∏",
    "21575413": "–ì—Ä–∞–Ω—É–ª—ã"
}

URLS = [
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=20488344&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=21516103&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=20488811&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=21516160&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=21516155&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=20496685&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=21516163&rl=0_undefined&source=widget",
    "https://dikidi.ru/ru/record/596993?p=3.pi-po-ssm-sd&o=7&s=21575413&rl=0_undefined&source=widget"
]

CHECK_INTERVAL = 300  # 5 –º–∏–Ω—É—Ç
MAX_ERRORS = 3

# =============================================

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('monitor.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

bot = telebot.TeleBot(TELEGRAM_TOKEN)

HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
    'Referer': 'https://dikidi.ru/'
}

# –•—Ä–∞–Ω–∏–ª–∏—â–µ: {url: {'message_id': 123, 'error_count': 0, 'last_error_time': None}}
url_state = {}

def format_datetime(datetime_str):
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥"""
    try:
        dt = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S")
        return dt.strftime("%d.%m.%Y –≤ %H:%M")
    except:
        try:
            dt = datetime.strptime(datetime_str, "%Y-%m-%d")
            return dt.strftime("%d.%m.%Y")
        except:
            return datetime_str

def send_alert(url, service_id, service_name, booking_info):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram (—Å –ü–û–õ–ù–´–ú –Ω–∞–∑–≤–∞–Ω–∏–µ–º)"""
    
    if service_name:
        work_info = f"üìö *{service_name}*"
    else:
        work_info = f"üÜî ID: {service_id}"
    
    message = f"üö® *–ï–°–¢–¨ –ú–ï–°–¢–ê!*\n\n{work_info}\n\n"
    
    if booking_info.get('first_datetime'):
        message += f"üìÖ *–ü–µ—Ä–≤–∞—è –∑–∞–ø–∏—Å—å:* `{booking_info['first_datetime']}`\n"
    
    if booking_info.get('available_dates'):
        message += f"üìÜ *–î–Ω–µ–π –¥–æ—Å—Ç—É–ø–Ω–æ:* {booking_info['available_dates']}\n"
    
    message += f"\nüîó [–ó–∞–ø–∏—Å–∞—Ç—å—Å—è —Å–µ–π—á–∞—Å]({url})"
    message += "\n\n‚ö°Ô∏è _–ú–µ—Å—Ç–∞ –±—ã—Å—Ç—Ä–æ —Ä–∞–∑–±–∏—Ä–∞—é—Ç!_"
    
    try:
        msg = bot.send_message(CHAT_ID, message, parse_mode='Markdown')
        if url not in url_state:
            url_state[url] = {}
        url_state[url]['message_id'] = msg.message_id
        url_state[url]['last_sent'] = datetime.now()
        logging.info(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {service_id}")
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")

def delete_alert(url, service_id):
    """–£–¥–∞–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ–≥–¥–∞ –º–µ—Å—Ç–∞ –ø—Ä–æ–ø–∞–¥–∞—é—Ç"""
    if url in url_state and 'message_id' in url_state[url]:
        try:
            bot.delete_message(CHAT_ID, url_state[url]['message_id'])
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ—Ä–æ—Ç–∫–æ–µ –∏–º—è –¥–ª—è –ª–æ–≥–∞
            short_name = LAB_SHORT_NAMES.get(service_id, service_id)
            logging.info(f"üóëÔ∏è –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ: {short_name}")
            if 'message_id' in url_state[url]:
                del url_state[url]['message_id']
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}")

def send_error_alert(url, service_id, error_msg):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å —Å—Å—ã–ª–∫–æ–π"""
    # –î–ª—è Telegram –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
    service_name = LAB_NAMES.get(service_id, service_id)
    message = (
        f"‚ö†Ô∏è *–ü–†–û–ë–õ–ï–ú–ê –° –ó–ê–ü–ò–°–¨–Æ*\n\n"
        f"üìö {service_name}\n"
        f"üÜî ID: {service_id}\n"
        f"‚ùå –û—à–∏–±–∫–∞: {error_msg}\n\n"
        f"üîó [–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—Ä—É—á–Ω—É—é]({url})"
    )
    try:
        bot.send_message(CHAT_ID, message, parse_mode='Markdown')
        logging.warning(f"üö® –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ: {service_id}")
    except Exception as e:
        logging.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: {e}")

def check_page(url):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –º–µ—Å—Ç.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (is_available, booking_info, error_msg)
    """
    booking_info = {'first_datetime': '', 'available_dates': 0}
    
    try:
        response = requests.get(url, headers=HEADERS, timeout=15)
        
        if response.status_code == 429:
            return None, booking_info, "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ (429)"
        elif response.status_code == 403:
            return None, booking_info, "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω (403)"
        elif response.status_code != 200:
            return None, booking_info, f"–û—à–∏–±–∫–∞ {response.status_code}"

        html = response.text
        match = re.search(r'data-options=\'({.*?})\'\s*>', html, re.DOTALL)
        
        if not match:
            return None, booking_info, "–ù–µ –Ω–∞–π–¥–µ–Ω–æ data-options"
        
        try:
            options_json = match.group(1).replace('\\"', '"').replace('\\/', '/')
            data = json.loads(options_json)
        except json.JSONDecodeError as e:
            return None, booking_info, f"–û—à–∏–±–∫–∞ JSON: {str(e)[:50]}"
        
        step_data = data.get('step_data', {})
        dates_true = step_data.get('dates_true', [])
        times = step_data.get('times', {})
        masters = step_data.get('masters', {})
        first_date_true = step_data.get('first_date_true', '')
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–≤–æ–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –≤—Ä–µ–º—è
        first_datetime = ''
        if times:
            all_times = []
            for time_slots in times.values():
                all_times.extend(time_slots)
            if all_times:
                all_times.sort()
                first_datetime = format_datetime(all_times[0])
        elif first_date_true:
            first_datetime = format_datetime(first_date_true)
        
        booking_info['first_datetime'] = first_datetime
        booking_info['available_dates'] = len(dates_true)
        
        is_available = len(dates_true) > 0 or len(times) > 0 or len(masters) > 0 or bool(first_date_true)
        
        return is_available, booking_info, None
            
    except requests.exceptions.Timeout:
        return None, booking_info, "–¢–∞–π–º-–∞—É—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"
    except requests.exceptions.ConnectionError:
        return None, booking_info, "–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"
    except Exception as e:
        return None, booking_info, f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)[:50]}"

def get_service_info(url):
    service_id = "Unknown"
    if 's=' in url:
        service_id = url.split('s=')[1].split('&')[0]
    # –ü–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è Telegram)
    service_name = LAB_NAMES.get(service_id, "")
    # –ö–æ—Ä–æ—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è –ª–æ–≥–æ–≤)
    short_name = LAB_SHORT_NAMES.get(service_id, service_id)
    return service_id, service_name, short_name

def main():
    logging.info(f"üîç –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω ({len(URLS)} —Å—Å—ã–ª–æ–∫)")
    logging.info(f"üìù –õ–æ–≥ –ø–∏—à–µ—Ç—Å—è –≤ monitor.log")
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è URL
    for url in URLS:
        url_state[url] = {'error_count': 0, 'last_error_time': None}
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–ø—É—Å–∫–µ
    try:
        bot.send_message(
            CHAT_ID, 
            f"üü¢ *–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω!*\n\n"
            f"üìä –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è: {len(URLS)} —Ä–∞–±–æ—Ç\n"
            f"‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª: {CHECK_INTERVAL} —Å–µ–∫\n"
            f"üïí –í—Ä–µ–º—è: {datetime.now().strftime('%d.%m.%Y %H:%M')}",
            parse_mode='Markdown'
        )
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–ø—É—Å–∫–µ: {e}")

    while True:
        try:
            for url in URLS:
                # –ü–æ–ª—É—á–∞–µ–º ID, –ø–æ–ª–Ω–æ–µ –∏–º—è (–¥–ª—è TG) –∏ –∫–æ—Ä–æ—Ç–∫–æ–µ –∏–º—è (–¥–ª—è –ª–æ–≥–æ–≤)
                service_id, service_name, short_name = get_service_info(url)
                
                is_available, booking_info, error_msg = check_page(url)
                
                # --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ ---
                if error_msg:
                    url_state[url]['error_count'] = url_state[url].get('error_count', 0) + 1
                    url_state[url]['last_error_time'] = datetime.now()
                    
                    # –í –ª–æ–≥–∞—Ö –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ—Ä–æ—Ç–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
                    logging.warning(f"‚ö†Ô∏è {short_name}: {error_msg} (–æ—à–∏–±–æ–∫ –ø–æ–¥—Ä—è–¥: {url_state[url]['error_count']})")
                    
                    if url_state[url]['error_count'] >= MAX_ERRORS:
                        last_warn = url_state[url].get('last_warning_time')
                        if not last_warn or (datetime.now() - last_warn).total_seconds() > 1800:
                            send_error_alert(url, service_id, error_msg)
                            url_state[url]['last_warning_time'] = datetime.now()
                            url_state[url]['error_count'] = 0
                    
                    if url_state[url].get('message_id'):
                        delete_alert(url, service_id)
                    
                    continue
                
                url_state[url]['error_count'] = 0
                was_available = url_state[url].get('was_available', False)
                
                if is_available and not was_available:
                    send_alert(url, service_id, service_name, booking_info)
                elif not is_available and was_available:
                    delete_alert(url, service_id)
                
                url_state[url]['was_available'] = is_available
                
                # –í—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å (–ö–û–†–û–¢–ö–û–ï –Ω–∞–∑–≤–∞–Ω–∏–µ)
                if is_available:
                    time_info = booking_info.get('first_datetime', '')
                    logging.info(f"‚úÖ {short_name}: {time_info or '–¥–∞—Ç—ã –µ—Å—Ç—å'}")
                else:
                    logging.debug(f"‚ùå {short_name}: –Ω–µ—Ç –º–µ—Å—Ç")

            sleep_time = CHECK_INTERVAL + random.randint(0, 10)
            logging.info(f"üí§ –ü–∞—É–∑–∞ {sleep_time} —Å–µ–∫ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏...")
            time.sleep(sleep_time)
            
        except KeyboardInterrupt:
            logging.info("‚õî –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
            try:
                bot.send_message(CHAT_ID, "üî¥ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", parse_mode='Markdown')
            except:
                pass
            break
        except Exception as e:
            logging.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: {e}")
            time.sleep(10)

if __name__ == "__main__":
    main()
